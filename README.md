# 操作系统（陈向群）

## 第1讲 操作系统概述

### 1.1 操作系统的定义及作用

#### 操作系统的三个作用

- 资源的管理者 → 有效
  - 自底向上

- 向用户提供各种服务 → 方便使用
  - 系统调用：进程的创建、执行；文件和目录的操作；I/O设备的使用；各类统计信息

- 对硬件机器的扩展 → 扩展能力
  - 硬件之上的第一层软件

### 1.2 操作系统的特征

#### 操作系统的主要特征

- 并发（concurrency）：指处理多个同时性活动的能力
  - 并行（parallel）：与并发相似，但多指不同程序同时在多个硬件部件上执行
- 共享（sharing）： 操作系统与多个用户的程序共同使用计算机系统中的资源（共享有限的系统资源）
  - 互斥共享、同时共享
- **虚拟**（virtual）：一个物理实体映射为若干个对应的逻辑实体—分时或分空间
  - 提高资源利用率
  - 虚处理机、虚拟地址空间、虚拟终端
- 随机： 操作系统必须随时对以不可预测的次序发生的事件进行响应并处理
  - 进程的运行速度不可预知、难以重现系统在某个时刻的状态

### 1.3 典型的操作系统架构

#### Windows

- 应用程序
- 系统功能调用
- 操作系统
- 计算机硬件

#### Android

- Android应用程序
- 应用程序框架
- 系统库和Android运行时
- Linux内核

### 1.4 操作系统分类

#### SPOOLING技术

- 同时的外围设备联机操作 ，又称假脱机技术（Simultaneous Peripheral Operation On-Line）
- 利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O和计算真正并行
- 现代计算机系统的打印过程通常采用的是SPOOLING技术

<img src="https://github.com/JasonWangGit/OperatingSystem/blob/master/image/SPOOLING%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" style="zoom:30%;" />

#### 传统的操作系统分类

- 批处理操作系统 
- 分时系统 
  - 时间片（time slice）：操作系统将CPU的时间划分成若干个片段，称为时间片
  - 通用操作系统：分时优先，批处理在后
    - “前台”：需要频繁交互的作业
    - “后台”：时间性要求不强的作业
- 实时操作系统
  - 硬实时系统、软实时系统
- 个人计算机操作系统 
- 网络操作系统 
- 分布式操作系统 
  - 或以计算机网络为基础，或以多处理机为基础，基本特征是处理分布在不同计算机上
- 嵌入式操作系统

## 第2讲 操作系统运行环境与运行机制



<img src="https://github.com/JasonWangGit/OperatingSystem/blob/master/image/%E7%AC%AC2%E8%AE%B2.png" alt="第2讲" style="zoom:30%;" />

### 2.1 处理器状态（模式）

#### 两类寄存器

- 用户可见寄存器
- 控制和状态寄存器
  - 程序计数器（PC：Program Counter），记录将要取出的指令的地址 
  - 指令寄存器（IR：Instruction Register），记录最近取出的指令 
  - 程序状态字（PSW：Program Status Word），记录处理器的运行状态如条件码、模式、控制位等信息

#### 两种状态

- 内核态(Kernel Mode)：运行操作系统程序
  - 特权(privilege)指令：只能由操作系统使用、用户程序不能使用的指令
    - 启动I/O、内存清零、修改程序状态字、设置时钟、允许/禁止中断 、停机
- 用户态(User Mode)：运行用户程序
  - 非特权指令：用户程序可以使用的指令
    - 控制转移、算术运算、访管指令（由用户态陷入内核态）、取数指令

#### 状态之间的转换

- 用户态 → 内核态 
  - 唯一途径 → 中断/异常/陷入机制
  - 一条特殊的指令：陷入指令（又称访管指令：访问管理态supervisor mode）
    - 提供给用户程序的接口，用于调用操作系统的功能（服务） 
      - 例如：int，trap，syscall，sysenter/sysexit
- 内核态 → 用户态 
  - 设置程序状态字PSW

### 2.2 中断/异常机制（操作系统的驱动力）

- 中断/异常 对于操作系统的重要性
  - 就好比：汽车的发动机、飞机的引擎
  - 操作系统是由“中断驱动”或者“事件驱动”的

- CPU对系统发生的某个事件作出的一种反应
  - CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点， 继续执行被打断的程序

- 中断的引入：为了支持CPU和设备之间的并行操作
  - 小明学习过程中接电话
- 异常的引入：表示CPU执行指令时本身出现的问题
  - 小明学习过程中喝水（口渴了）

#### 事件

- 中断（外中断）：外部事件，正在运行的程序所不期望的 
  - I/O中断 
    - ctrl+c、网络接收包、打印结束、读盘结束
  - 时钟中断
    - 定时器结束、时间片结束
  - 硬件故障
    - 电脑没电、读内存奇偶校验错
- 异常（内中断）：由正在执行的指令引发
  - 系统调用
  - 页故障/页错误 
    - 缺页异常
  - 保护性异常 
    - 写入只读区域、访问区域越界
  - 断点指令 
    - 单步调试
  - 其他程序性异常 (如算术溢出等)
    - 除0

#### 中断异常的小结

<img src="https://github.com/JasonWangGit/OperatingSystem/blob/master/image/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B0%8F%E7%BB%93.png" style="zoom:30%;" />

### 2.3 中断/异常机制工作原理

硬件和软件相互配合而使计算机系统得以充分发挥能力。

- 硬件该做什么事？—中断/异常响应
  - 捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序
- 软件要做什么事？—中断/异常处理程序
  - 识别中断/异常类型并完成相应的处理

#### 中断响应

- 中断响应：发现中断、接收中断的过程
  - 由中断硬件部件完成

1. 设备发中断信号
2. 硬件保存现场（主要是程序计数器PC、程序状态字PSW）
3. 根据中断码查表
4. 把中断处理程序入口地址等推送到相应的寄存器
5. 执行中断处理程序

##### 中断向量表

- 中断向量：一个内存单元，存放中断处理程序入口地址和程序运行时所需的处理机状态字

#### 中断处理程序

- 设计操作系统时，为每一类中断/异常事件编好相应的处理程序，并设置好中断向量表

1. 保存相关寄存器信息 
2. 分析中断/异常的具体原因 
3. 执行对应的处理功能 
4. 恢复现场，返回被事件打断的程序

### 2.4 系统调用机制

- 系统调用：用户在编程时可以调用的操作系统功能
  - 系统调用是操作系统提供给编程人员的唯一接口 
  - 使CPU状态从用户态陷入内核态
- 系统调用方式
  - 应用程序 → 系统调用
  - 应用程序 → C函数库/API接口 → 系统调用

### 2.5 系统调用机制设计与执行过程

- 中断/异常机制
  - 支持系统调用服务的实现

- 选择一条特殊指令：陷入指令(亦称访管指令) 
  - 引发异常，完成用户态到内核态的切换 

- 系统调用号和参数 
  - 每个系统调用都事先给定一个编号(功能号)

- 系统调用表 
  - 存放系统调用服务例程的入口地址

#### 用户程序的参数传递给内核

常用的3种实现方法：

- 由陷入指令自带参数：陷入指令的长度有限，且还要携带系统调用功能号，只能自带有限的参数 
- （大多数情况）通过通用寄存器传递参数：这些寄存器是操作系统和用户程序都能访问的，但寄存器的个数会限制传递参数的数量 
- 在内存中开辟专用堆栈区来传递参数

#### 系统调用的执行过程

当CPU执行到特殊的陷入指令时：

1. 中断/异常机制：
   - 硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序 

2. 系统调用总入口程序：
   - 保存现场；将参数保存在内核堆栈里；
   - 通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数 

3. 执行系统调用例程 

4. 恢复现场，返回用户程序

## 第3讲 进程/线程模型

### 3.1 进程基本概念

#### 多道程序设计

- 允许多个程序同时进入内存并运行，其目的是为了提高系统效率

#### 并发环境与并发程序

- 并发环境：一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态， 并且次序不是事先确定的
- 并发程序：在并发环境中执行的程序 

#### 进程的定义

- 进程（对CPU的抽象）是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位
  - 程序的一次执行过程 
    - 同一程序运行两次，算两个进程
  - 是正在运行程序的抽象 
  - 将一个CPU变幻成多个虚拟的CPU 
  - 系统资源以进程为单位分配，如内存、文件、……
    -  每个具有独立的地址空间 
  - 操作系统将CPU调度给需要的进程

#### 进程控制块PCB

- PCB：Process Control Block 
  - 又称 进程描述符、进程属性 
  - 操作系统用于管理控制进程的一个专门数据结构 
  - 记录进程的各种属性，描述进程的动态变化过程
- PCB是系统感知进程存在的唯一标志
  - 进程与PCB是一一对应的
- 进程表：所有进程的PCB集合

##### PCB的内容

- 进程描述信息
  - 进程标识符(process ID)，唯一，通常是一个整数 
  - 进程名，通常基于可执行文件名， 不唯一 
  - 用户标识符(user ID) 
  - 进程组关系
- 进程控制信息
  - 当前状态
  - 优先级(priority) 
  - 代码执行入口地址 
  - 程序的磁盘地址 
  - 运行统计信息(执行时间、页面调度) 
  - 进程间同步和通信 
  - 进程的队列指针 
  - 进程的消息队列指针
- 所拥有的资源和使用情况
  - 虚拟地址空间的状况等
  - 打开文件列表
- CPU现场信息
  - 寄存器值(通用寄存器、程序计数器PC、程序状态字PSW、栈指针)
  - 指向该进程页表的指针

### 3.2 进程状态及状态转换

#### 进程的三种基本状态

进程的三种基本状态： 

- 运行态（Running）
  - 占有CPU，并在CPU上运行
- 就绪态（Ready）
  - 已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
- 等待态（Waiting/Blocked）：也称阻塞态、封锁态、睡眠态
  - 因等待某一事件而暂时不能运行
    - 如等待读盘结果

<img src="D:\Program Files\sts-bundle\source\OperatingSystem\image\三状态模型及状态转换.png" alt="三状态模型及状态转换" style="zoom:30%;" />

#### 进程的其他状态

- 创建（New）
  - 已完成创建一进程所必要的工作
    - PID、PCB
  - 但尚未同意执行该进程
    - 因为资源有限
- 终止（Terminated）
  - 终止执行后，进程进入该状态
  - 可完成一些数据统计工作
  - 资源回收
- 挂起（Suspend）
  - 用于调节负载  
  - 进程不占用内存空间，其进程映像交换到磁盘上

#### 进程队列

- 操作系统为每一类进程建立一个或多个队列 
  - 多个等待队列等待的事件不同 
  - 就绪队列也可以多个 
  - 单CPU情况下，运行队列中只有一个进程
- 队列元素为PCB 
- 伴随进程状态的改变，其PCB从一个队列进入另一个队列

### 3.3 进程控制

进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成 

- 进程创建原语 
- 进程撤消原语 
- 阻塞原语 
- 唤醒原语 
- 挂起原语 
- 激活原语 
- 改变进程优先级

##### 原语（primitive）

- 完成某种特定功能的一段程序，具有不可分割性或不可中断性 
  - 即原语的执行必须是连续的，在执行过程中不允许被中断 
  - 原子操作（atomic）

#### 进程的创建

- 给新进程分配一个唯一标识以及进程控制块 
- 为进程分配地址空间 
- 初始化进程控制块 
  - 设置默认值 (如: 状态为 New，...) 
- 设置相应的队列指针 
  - 如: 把新进程加到就绪队列链表中
- UNIX：fork/exec
- WINDOWS：CreateProcess

#### 进程的撤销

- 结束进程 
- 收回进程所占有的资源 
  - 关闭打开的文件、断开网络连接、回收分配的内存、…… 
- 撤消该进程的PCB
- UNIX：exit
- WINDOWS：TerminateProcess

#### 进程阻塞

- 处于运行状态的进程，在其运行过程中期待某一事件发生
  - 如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息
- 当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态
- UNIX：wait
- WINDOWS：WaitForSingleObject

#### UNIX几个进程控制操作（系统调用）

- fork() 通过复制调用进程来建立新的进程，是最基本的进程建立过程 
- exec() 包括一系列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换 
- wait() 提供初级进程同步操作，能使一个进程等待另外一个进程的结束 
- exit() 用来终止一个进程的运行

### 3.4 深入理解进程概念

#### 进程的分类

- 系统进程 VS 用户进程
- 前台进程 VS 后台进程
- CPU密集型进程 VS I/O密集型进程

#### 进程层次结构

- UNIX进程家族树：init为根
- Windows：地位相同

#### 进程与程序的区别

- 进程更能准确刻画并发，而程序不能 
- 程序是静态的，进程是动态的 
- 进程有生命周期的，有诞生有消亡，是短暂的
  - 而程序是相对长久的 
- 一个程序可对应多个进程 
- 进程具有创建其他进程的功能
- 操作系统给每个进程都分配了一个地址空间

#### 进程映像

对进程执行活动全过程的静态描述。

- 用户相关：进程地址空间（包括代码段、数据段、 堆和栈、共享库……）
- 寄存器相关：程序计数器、指令寄存器、程序状态 寄存器、栈指针、通用寄存器等的值
- 内核相关： 
  - 静态部分：PCB及各种资源数据结构 
  - 动态部分：内核栈（不同进程在进入内核后使用 不同的内核栈）

#### 上下文切换

将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换。

- 进程运行时，其硬件状态保存在CPU上的寄存器中 
  - 寄存器：程序计数器、程序状态寄存器、栈指针、 通用寄存器、其他控制寄存器的值
- 进程不运行时，这些寄存器的值保存在进程控制块PCB中
  - 当操作系统要运行一个新的进程时，将 PCB中的相关值送到对应的寄存器中

### 3.5 线程的引入

为什么在进程中再派生线程？

- 应用的需要 
  - 进程并发无法共享内存空间
- 开销的考虑 
  - 进程相关的操作时间/空间开销大， 限制了并发度的提高
  - 线程的开销小
    - 创建一个新线程花费时间少（撤销亦如此） 
    - 两个线程切换花费时间少
    - 线程之间相互通信无须调用内核（同一进程内的线程共享内存和文件）
- 性能的考虑
  - 多个线程，有的计算，有的I/O

#### 线程的基本概念

<img src="D:\Program Files\sts-bundle\source\OperatingSystem\image\线程的基本概念.png" alt="线程的基本概念" style="zoom:30%;" />

- 线程：进程中的一个运行实体，是CPU的调度单位
  - 有时将线程称为轻量级进程
- 有标示符ID 
- 有状态及状态转换 → 需要提供一些操作 
- 不运行时需要保存的上下文 
  - 有上下文环境：程序计数器等寄存器 
- 有自己的栈和栈指针 √ 
- 共享所在进程的地址空间和其他资源 
- 可以创建、撤消另一个线程
  - 程序开始是以一个单线程进程方式运行的

### 3.6 线程机制的实现

- 用户级线程（UNIX）
  - 在用户空间建立线程库： 提供一组管理线程的过程 
  - 运行时系统：完成线程的管理工作（操作、线程表） 
  - 内核管理的还是进程，不知道线程的存在 
  - 线程切换不需要内核态特权
- 核心级线程（Windows）
  - 内核管理所有线程管理， 并向应用程序提供API 接口 
  - 内核维护进程和线程的上下文 
  - 线程的切换需要内核支持 
  - 以线程为基础进行调度
- 混合—两者结合方法（Solaris）
  - 线程创建在用户空间完成 
  - 线程调度等在核心态完成

